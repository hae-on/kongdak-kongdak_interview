# this

## this와 실행 컨텍스트

자바스크립트는 스크립트 언어로, 인터프리터에 의해 줄 단위로 읽혀서 해석되어 실행됩니다.

인터프리터에 의해 현재 실행되는 자바스크립트의 환경을 실행 컨텍스트라고 합니다. 자바스크립트 내부에서 이러한 실행 컨텍스트를 스택으로 관리하며, 실행되는 시점에 자주 변경되는 실행 컨텍스트를 this가 가리킵니다.

즉, this는 현재 실행되는 코드의 실행 컨텍스트를 가리킵니다.

Function.prototype 객체의 메서드인 call, apply, bind를 통해 명시적으로 this를 바인딩해줄 수도 있습니다.

## 함수 호출 방식과 this 바인딩

자바스크립트의 경우 함수 호출 방식에 의해 `this`에 바인딩할 어떤 객체가 동적으로 결정됩니다. 다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, **함수를 호출할 때 함수가 어떻게 호출되었는지에 따라** this에 바인딩할 객체가 동적으로 결정됩니다.

- 바인딩이란? - 프로그램의 어떤 기본 단위가 가질 수 있는 구성요소의 구체적인 값, 성격을 확정하는 것을 말합니다.

함수의 호출하는 방식은 아래와 같이 다양합니다.

1. 함수 호출

2. 메소드 호출

3. 생성자 함수 호출

4. apply/call/bind 호출

### 함수 호출

전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 브라우저에서는 `window`, Node.js에서는 `global` 객체를 의미합니다.

기본적으로 `this`는 전역 객체에 바인딩 됩니다. 전역함수는 물론이고 내부 함수의 경우도 `this`는 외부함수가 아닌 전역 객체에 바인딩 됩니다.

엄격 모드에서는 기본 바인딩 대상에서 전역 객체는 제외됩니다. 전역 객체를 참조해야 할 `this`가 있다면 그 값은 `undefined`가 됩니다.

**내부 함수는 일반 함수, 메소드, 콜백 함수 어디에서 선언되었든 관계없이 `this`는 전역 객체를 바인딩합니다.**

내부 함수의 `this`가 전역 객체를 참조하는 것을 회피하는 방법은 아래와 같습니다.

1. var that = this; 를 이용하여 객체의 this를 변수에 저장해서 사용

2. call, bind, apply로 this 설정

3. 화살표 함수 사용

### 메소드 호출

함수가 객체의 프로퍼티 값이면 메소드로서 호출됩니다.

이때 메소드 내부의 `this`는 **해당 메소드를 소유한 객체**, 즉 해당 메소드를 호출한 객체에 바인딩 됩니다.

프로토타입 객체도 메소드를 가질 수 있습니다.

프로토타입 객체 메소드 내부에서 사용된 `this`도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩 됩니다.

그래서 `this`의 프로퍼티를 찾을 때 우선 직접 바인딩 되어있는 프로토타입 오브젝트에서 찾고 없으면 체이닝에 의해 `new` 생성자로 생성된 객체에서 찾게 됩니다.

### 생성자 함수 호출

자바스크립트 생성자 함수는 말 그대로 객체를 생성하는 역할을 합니다.

하지만 자바와 같은 객체지향 언어의 생성자 함수와는 다르게 그 형식이 정해져 있는 것이 아니라 기존 함수에 `new` 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작합니다.

이는 반대로 생각하면 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있습니다. 따라서 일반적으로 생성자 함수명은 첫 문자를 대문자로 기술하여 혼란을 방지하려고 노력합니다.

### apply/call/bind 호출

this에 바인딩 될 객체는 함수 호출 패턴에 의해 결정됩니다. 이는 자바스크립트 엔진이 수행하는 것입니다. 이러한 자바스크립트 엔진의 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩하는 방법도 제공됩니다. 이것을 가능하게 하는 것이 Function.prototype.apply, Function.prototype.call 메소드입니다.

이 메소드들은 모든 함수 객체의 프로토타입 객체인 Function.prototype 객체의 메소드입니다.

- apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것입니다. 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩합니다.

- apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달합니다.

- call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달합니다.

```js
Person.apply(foo, [1, 2, 3]);

Person.call(foo, 1, 2, 3);
```

- Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달합니다.

## 화살표 함수

ES6에 추가된 화살표 함수(Arrow Function) 내부에서 `this`를 사용할 경우, `this`에 바인딩할 객체가 정적으로 결정되기 때문에 `call`, `apply`, `bind`로 `this`를 변경할 수 없습니다.

화살표 함수 내부의 `this`는 언제나 상위 스코프의 객체를 가리키는데, 이를 Lexical this(문맥적 this)라고 합니다.

Lexical this를 제공하기 때문에 콜백 함수로 사용하기 편리하지만, 화살표 함수를 사용해서는 안 되는 경우도 존재하므로 주의해야 합니다.

### 화살표 함수로 메서드를 선언하는 것은 위험합니다

객체의 메서드를 화살표 함수로 선언할 경우, `this`는 해당 객체가 아닌 전역 객체를 가리키게 되므로 주의해야 합니다.

이런 경우에는 ES6의 축약 메서드 표현을 사용하는 것이 좋습니다.

```js
var obj = {
    foo: "foo",
    print1: () => { console.log(this.foo) },
    print2 () { console.log(this.foo) }
}
obj.print1() // undefined
obj.print2() // foo
```

### 화살표 함수는 prototype 속성이 없습니다

```js
var Foo = () => {}
console.log(Foo.prototype) // undefined
var foo = new Foo()	   // TypeError: Foo is not a constructor
```

### addEventListener의 콜백 함수

화살표 함수는 콜백 함수로 사용하기 편리합니다. 하지만 addEventListener의 콜백 함수의 경우, 이벤트 리스너에 바인딩 된 요소를 가리켜야 하는데 이때 화살표 함수를 사용하면 전역 객체를 가리키게 되므로 주의해야 합니다.